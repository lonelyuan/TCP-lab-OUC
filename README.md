# TCP实验报告

### 构造可靠数据传输RDT
- 1.0：理想模型——完全可靠信道
- 2.0：ARQ：自动重传——比特差错
  - 返回ACK/NAK
  - 2.1：序号，应对ACK/NAK出错阻塞
      - 停等协议，序号只需要1位
      - 【实现略】
  - 2.2：去除NAK
      - 仅对上次正确传输的分组发送ACK
- 3.0：超时重传——信道丢包
  - 发送方启动定时器
- 4.0：流水线化——交付失序
  - 缓存失序包，维护接收/发送窗口
  - 4.1 GBN：回退N步
    - 失序包之后的包全部丢弃
    - 【实现略】
  - 4.2 SR：选择重传
  - 4.3 TCP初版：单个计时器
- 5.0：阻塞控制——加强性能
    - 5.1 Tahoe
      - 慢启动，阻塞避免，快重传
    - 5.2 Reno
      - 快恢复

### 设置错误控制标志
- 0.信道无差错
- 1.只出错
- 2.只丢包
- 3.只延迟
- 4.出错 / 丢包
- 5.出错 / 延迟
- 6.丢包 / 延迟
- 7.出错 / 丢包 / 延迟

### 重大问题

#### log的艺术

#### 并发编程

如何正确处理窗口的互斥访问是一个难点。
对于接收方来说，可以根据接收事件来驱动窗口的更新，故相对不涉及并发编程；
而对于发送方，既要及时响应上层调用，又要持续监听ACK，以实现重传。故发送窗口的维护至少会同时出现两个线程：

- 主循环：不断遍历窗口，删除有序已确认部分，触发重传
- 监听ACK：修改窗口项的状态，也需要找到对应窗口

如果遍历和修改同时发生在一个窗口项上，就会触发ConcurrentModificationException异常

为了正确处理并发，需要用锁将


#### 计时器实现

单一计时器的一种思路：针对主循环

#### java数组索引

sublist你就是个几把

#### 重传包错位 | 花费时间：>3 hours

在实现重传时，对象引用总是错位，一怒之下👴不传窗口对象了，传序号再查找行了吧。然后发现窗口里的所有项都总是指向最新的包，👴傻了。

这时候才发现构造方法里一直是传引用，而TCP_PACKET实例一直只有一个。而即使用final修饰，引用指向的对象还是可以变。

解决方法：使用构造窗口项对象时使用clone方法。
