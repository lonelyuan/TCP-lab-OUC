# TCP实验报告

### 可靠数据传输RDT里程碑

- 1.0：理想模型——完全可靠信道
- [x]  2.0：ARQ：自动重传——比特差错
  - 返回ACK/NAK
  - 2.1：序号，应对ACK/NAK出错阻塞
      - 停等协议，序号只需要1位
  - [x] 2.2：去除NAK
      - 仅对上次正确传输的分组发送ACK
- [x] 3.0：超时重传——信道丢包
  
  - 发送方启动定时器
-  4.0：流水线化——交付失序
  - 缓存失序包，维护接收/发送窗口
  - 4.1 GBN：回退N步
  - [x] 4.2 SR：选择重传
  - [x] 4.3 TCP初版
    - 单个计时器
  
- 5.0：阻塞控制——加强性能
  - [x] 5.1 Tahoe
    - 慢启动，阻塞避免，快重传
  - [x] 5.2 Reno
    - 快恢复

### 设置错误控制标志
- 0.信道无差错
- 1.只出错
- 2.只丢包
- 3.只延迟
- 4.出错 / 丢包
- 5.出错 / 延迟
- 6.丢包 / 延迟
- 7.出错 / 丢包 / 延迟

### 重大问题

#### 发送窗口和并发编程 | 花费时间：>4 hours

如何正确处理窗口的互斥访问是一个难点。

对于接收方来说，可以根据接收事件来驱动窗口的更新，故相对不涉及并发编程；
而对于发送方，既要及时响应上层调用，又要持续监听ACK，以实现重传。故发送窗口的维护至少会同时出现两个线程：(infinity window版本)

- 主循环`mainloop()`：不断遍历窗口，删除有序已确认部分，触发重传
- 监听ACK事件`recv()`：修改窗口项的状态，也需要找到对应窗口

如果遍历和修改同时发生在一个窗口项上，就会触发`ConcurrentModificationException`异常。

为了正确处理并发，可以用`synchronized`关键字（也就是锁）将要修改的窗口项保护起来，或者使用`CopyonWrite`数组，然而使用效果并不好。

**解决方法：**

最后注意到，由于RTT较短，我们也可以消灭主循环，全部让ACK事件来推动窗口，这样窗口的维护由两个函数触发：(RDT4.2最终版本)

- 应用层接口调用`rdt_send()`：发包，加入窗口
- 监听ACK事件`recv()`：修改对应项状态，刷新窗口

由于发送事件必然比对应的ACK事件早，故可以彻底解决并发问题。（解决并发问题的方法就是不并发）


#### 重传包错位和数组索引 | 花费时间：>3 hours

TCP初版对单一计时器的实现是，只重传第一个未应答包。问题是，用什么找到待重传的那个包？

首先，排除传数组索引的方法，因为窗口在不断变化，索引值是不可靠的。此处点名`SubList()`方法，不要在涉及修改数组的情景下使用这个方法，害人不浅。

其次，使用传引用时，找到的重传包和实际发送的重传包总是错位。

最后，笔者一怒之下决定传包序号+遍历查找。然而还是错位。

几经debug，才发现窗口里的所有项都总是指向最新的包，👴傻了。
这时候才发现构造方法里`TCP_PACKET`成员的一直是引用，而`TCP_PACKET`实例一直只有一个。即使用`final`修饰引用，引用指向的对象还是可以变。

**解决方法：**

使用构造窗口项对象时使用`clone()`方法。
